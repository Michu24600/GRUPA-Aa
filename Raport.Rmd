---
title: "Analiza Rynku Mieszkaniowego"
subtitle: "Raport analityczny "
author: "Grupa AA"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: flatly
    toc: true             
    toc_float: true        
    number_sections: false 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r biblioteki, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8,fig.width=16}
if(!require("dplyr")) install.packages("dplyr")
library(dplyr)
if(!require("naniar")) install.packages("naniar")
library(naniar)
if(!require("VIM")) install.packages("VIM")
library(VIM)
if(!require("tidyr")) install.packages("tidyr")
library(tidyr)
if(!require("randomForest")) install.packages("randomForest")
library(randomForest)
if (!require("validate")) {install.packages("validate")}
library(validate)
if (!require("leaflet")) {install.packages("leaflet")}
library(leaflet)
if (!require("scales")) {install.packages("scales")}
library(scales)
if (!require("ggplot2")) {install.packages("ggplot2")}
library(ggplot2)
if (!require("hexbin")) {install.packages("hexbin")}
library(hexbin)
if (!require("gganimate")) {install.packages("gganimate")}
library(gganimate)
if (!require("gifski")) {install.packages("gifski")}
library(gifski) 
if (!requireNamespace("ggmap", quietly = TRUE)) { install.packages("ggmap")} 
library(ggmap)
if (!requireNamespace("shiny", quietly = TRUE)) { install.packages("shiny")}
library(shiny)
if (!requireNamespace("shinythemes", quietly = TRUE)) {install.packages("shinythemes")}
library(shinythemes)
```

# 1. WstÄ™p i Cel Projektu

**ğŸ¯ Cel Analizy** GÅ‚Ã³wnym celem niniejszego projektu jest identyfikacja oraz analiza kluczowych determinant ksztaÅ‚tujÄ…cych ceny nieruchomoÅ›ci w Polsce w roku 2024. Projekt skupia siÄ™ na zbadaniu zaleÅ¼noÅ›ci miÄ™dzy cechami fizycznymi i lokalizacyjnymi mieszkaÅ„ a ich wycenÄ… rynkowÄ….

CaÅ‚y proces analityczny obejmuje kompleksowe podejÅ›cie do danych: od ich czyszczenia (Data Cleaning) i inÅ¼ynierii cech (Feature Engineering), poprzez eksploracyjnÄ… analizÄ™ danych (EDA) i wizualizacjÄ™ przestrzennÄ…, aÅ¼ po modelowanie statystyczne.

## 1.1 Pytania Badawcze

W toku analizy staramy siÄ™ znaleÅºÄ‡ odpowiedzi na nastÄ™pujÄ…ce pytania:

[MIEJSCE NA PYTANIE BADAWCZE 1]

[MIEJSCE NA PYTANIE BADAWCZE 2]

[MIEJSCE NA PYTANIE BADAWCZE 3]

[MIEJSCE NA PYTANIE BADAWCZE 4]

## 1.2 O Danych

Analiza zostaÅ‚a przeprowadzona na zbiorze danych zawierajÄ…cym oferty sprzedaÅ¼y mieszkaÅ„ z czerwca 2024 roku.

**Å¹rÃ³dÅ‚o danych:** [<https://www.kaggle.com/datasets/krzysztofjamroz/apartment-prices-in-poland/?select=apartments_pl_2023_08.csv>]

## 1.3 ğŸ“– SÅ‚ownik Zmiennych (Data Dictionary)

PoniÅ¼sza tabela przedstawia opis zmiennych dostÄ™pnych w analizowanym zbiorze danych:

```{r data_dictionary, echo=FALSE,message=FALSE,warning=FALSE}
# Najpierw upewnij siÄ™, Å¼e masz pakiet: install.packages("kableExtra")
library(kableExtra)
library(dplyr)

# Tworzymy dane rÄ™cznie
slownik <- tibble::tribble(
  ~"Nazwa Zmiennej", ~"Opis", 
  "id", "Unikalny identyfikator ogÅ‚oszenia", 
  "city", "Miasto, w ktÃ³rym znajduje siÄ™ nieruchomoÅ›Ä‡", 
  "price", "Cena ofertowa (PLN) ", 
  "squareMeters", "Powierzchnia mieszkania w mÂ²", 
  "rooms", "Liczba pokoi", 
  "floor / floorCount", "PiÄ™tro mieszkania / Liczba piÄ™ter", 
  "buildYear", "Rok budowy budynku", 
  "type", "Rodzaj zabudowy ", 
  "ownership", "Forma wÅ‚asnoÅ›ci", 
  "lat / lon", "WspÃ³Å‚rzÄ™dne geograficzne", 
  "centreDistance", "OdlegÅ‚oÅ›Ä‡ od centrum (km)", 
  "poiCount", "Liczba punktÃ³w POI (500m)", 
  "*Distance", "OdlegÅ‚oÅ›ci do: szkÃ³Å‚, przychodni itp.", 
  "has*Parking, Balkon, Winda, Ochrona...", "Czy ma dane udogodnienie (TAK/NIE)", 
)

kbl(slownik, caption = "SÅ‚ownik Zmiennych (Data Dictionary)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                full_width = F, 
                position = "center",
                font_size = 14) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2c3e50") %>% 
  column_spec(1, bold = TRUE, color = "#2980b9") 
```

# 2. PorzÄ…dkowanie i czyszczenie danych

Proces przygotowania danych do analizy zostaÅ‚ podzielony na kilka kluczowych etapÃ³w: definicjÄ™ reguÅ‚ poprawnoÅ›ci, wstÄ™pnÄ… walidacjÄ™, imputacjÄ™ brakÃ³w danych (metodami statystycznymi i uczenia maszynowego) oraz weryfikacjÄ™ koÅ„cowÄ….

## 2.1. Definicja ReguÅ‚ Walidacyjnych

Przed przystÄ…pieniem do czyszczenia zdefiniowano zestaw reguÅ‚ logicznych przy uÅ¼yciu pakietu validate. PozwoliÅ‚o to na identyfikacjÄ™ bÅ‚Ä™dÃ³w w surowym zbiorze danych.

Sprawdzono m.in.:

SpÃ³jnoÅ›Ä‡ logicznÄ…: Czy piÄ™tro mieszkania nie jest wyÅ¼sze niÅ¼ liczba piÄ™ter w budynku (Logic_Floor).

Zasady budowlane: Czy w budynkach jednopiÄ™trowych nie zadeklarowano windy (Logic_Elevator).

WiarygodnoÅ›Ä‡ cen: Czy cena mieÅ›ci siÄ™ w przedziale 100 tys. â€“ 10 mln PLN.

GeolokalizacjÄ™: Czy wspÃ³Å‚rzÄ™dne geograficzne znajdujÄ… siÄ™ w granicach Polski (Bounding Box).

KompletnoÅ›Ä‡ dystansÃ³w: Czy odlegÅ‚oÅ›ci do punktÃ³w POI sÄ… wartoÅ›ciami dodatnimi.

WstÄ™pna walidacja wykazaÅ‚a naruszenia, ktÃ³re zostaÅ‚y skorygowane w kolejnych krokach.

```{r Wykres obrazujÄ…cy naruszenia, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8,fig.width=16}
if (!require("validate")) install.packages("validate")
library(validate)
if(file.exists("apartments_data_2024_06.RData")) {
  load("apartments_data_2024_06.RData")
}
rules_apartments <- validator(
  Logic_Floor = floorCount >= floor,
  Logic_Small_Apt = if (squareMeters <= 20) rooms <= 3,
  Logic_Elevator = if (floorCount <= 1) hasElevator == "no",
  Range_Price = price >= 100000 & price <= 10000000,
  Geo_Poland_Lat = latitude >= 49.0 & latitude <= 54.9,
  Geo_Poland_Lon = longitude >= 14.1 & longitude <= 24.2,
  Limit_Area_Max = squareMeters < 300,
  Limit_Year_Max = buildYear < 2025,
  Positive_Basic = id > 0 & price > 0 & rooms > 0 & squareMeters > 0,
  Positive_Building = buildYear > 0 & floorCount > 0 & floor >= 0, 
  Positive_Geo_POI = latitude > 0 & longitude > 0 & poiCount >= 0,
  Positive_Distances = centreDistance > 0 & schoolDistance > 0 & clinicDistance > 0 & 
    postOfficeDistance > 0 & kindergartenDistance > 0 & restaurantDistance > 0 & 
    collegeDistance > 0 & pharmacyDistance > 0
)

cf_apartments <- confront(apartments_data_2024_06, rules_apartments)
wyniki <- summary(cf_apartments)
macierz_danych <- t(wyniki[ , c("fails", "nNA", "passes")])

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Polskie etykiety dla wykresu trzeba sprawdziÄ‡ czy majÄ… sens
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
polskie_etykiety <- c(
  "PiÄ™tro > PiÄ™tra budynku",
  "Za duÅ¼o pokoi (kawalerki)",
  "Brak windy (niski blok)",
  "Cena poza zakresem",
  "ZÅ‚a szerokoÅ›Ä‡ geogr.",
  "ZÅ‚a dÅ‚ugoÅ›Ä‡ geogr.",
  "MetraÅ¼ > 300m",
  "Rok budowy > 2025",
  "Ujemne wartoÅ›ci (podst.)",
  "BÅ‚Ä™dy budynku (rok/piÄ™tra)",
  "BÅ‚Ä™dy Geo/POI",
  "Ujemne dystanse"
)
layout(matrix(c(1, 2), nrow = 2), heights = c(8, 1))

par(mar = c(2, 18, 4, 2)) 
barplot(macierz_danych, 
        main = "Struktura jakoÅ›ci danych (Walidacja)",
        names.arg = polskie_etykiety,
        horiz = TRUE,
        las = 1,
        col = c("#e74c3c", "#95a5a6", "#27ae60"), 
        border = NA
)

par(mar = c(0, 0, 0, 0))
plot.new() 
legend("center", 
       legend = c("BÅ‚Ä™dy", "Braki danych", "Poprawne"), 
       fill = c("#e74c3c", "#95a5a6", "#27ae60"), 
       bty = "n", 
       horiz = TRUE, 
       cex = 1.2 
)
```

## 2.2. Strategia Czyszczenia i Imputacji

WdroÅ¼ono wieloetapowy potok przetwarzania danych (pipeline), obejmujÄ…cy:

Wykluczenie zmiennych buildingMaterial oraz condition. Decyzja ta zostaÅ‚a podyktowana znacznym stopniem niekompletnoÅ›ci danych (brakujÄ…ce wartoÅ›ci) oraz niskÄ… jakoÅ›ciÄ… informacji ÅºrÃ³dÅ‚owych, co uniemoÅ¼liwiaÅ‚o przeprowadzenie rzetelnej analizy statystycznej w tym zakresie.

Imputacja logiczna:

Braki w liczbie piÄ™ter (floor) uzupeÅ‚niono wartoÅ›ciÄ… mediany (3) lub wartoÅ›ciÄ… floorCount, jeÅ›li byÅ‚a mniejsza niÅ¼ 3.

InformacjÄ™ o windzie (hasElevator) wywnioskowano na podstawie wysokoÅ›ci budynku (przyjÄ™to, Å¼e budynki powyÅ¼ej 4 piÄ™ter posiadajÄ… windÄ™).

Imputacja statystyczna (Dystanse): BrakujÄ…ce odlegÅ‚oÅ›ci do punktÃ³w usÅ‚ugowych (\*Distance) uzupeÅ‚niono Å›redniÄ… arytmetycznÄ… obliczonÄ… lokalnie dla kaÅ¼dego miasta.

Imputacja algorytmiczna (kNN): BrakujÄ…cy rok budowy (buildYear) uzupeÅ‚niono metodÄ… k-NajbliÅ¼szych SÄ…siadÃ³w (kNN), bazujÄ…c na podobieÅ„stwie pod wzglÄ™dem liczby punktÃ³w POI oraz odlegÅ‚oÅ›ci od centrum.

```{r cleaning_logic, message=FALSE, warning=FALSE,results='hide'}
# Definicja kolumn do imputacji Å›redniÄ…
distance_cols <- c(
  "collegeDistance", "clinicDistance", "restaurantDistance", 
  "pharmacyDistance", "postOfficeDistance", "kindergartenDistance", 
  "schoolDistance"
)
distance_vars_for_knn <- c("poiCount", "centreDistance")
apartments_processed <- apartments_data_2024_06 %>%
  # 1. Wykluczenie zmiennych o niskiej jakoÅ›ci
  select(-buildingMaterial, -condition) %>%
  
  # 2. Imputacja logiczna: PiÄ™tra
  # UzupeÅ‚nienie braku medianÄ… (3) lub floorCount (jeÅ›li budynek jest niÅ¼szy)
  mutate(
    floor = if_else(is.na(floor), pmin(3, floorCount), floor)
  ) %>%
  
  # 3. Imputacja logiczna: Windy
  mutate(
    hasElevator = case_when(
      (is.na(hasElevator) | hasElevator == "") & floor > 4 ~ "yes",
      (is.na(hasElevator) | hasElevator == "") & floor <= 4 ~ "no",
      TRUE ~ hasElevator
    )
  ) %>%
  
  # 4. Imputacja statystyczna: Dystanse (Å›rednia w grupach miast)
  group_by(city) %>%
  mutate(
    across(
      .cols = all_of(distance_cols),
      .fns = ~ replace(., is.na(.), mean(., na.rm = TRUE))
    )
  ) %>%
  
  # 5. Imputacja kNN: Rok budowy (buildYear)
  group_modify(~ {
    VIM::kNN(
      .x, 
      variable = "buildYear",
      dist_var = c("poiCount", "centreDistance"), 
      k = 5,
      imp_var = FALSE
    )
  }) %>%
  ungroup() %>%
  mutate(buildYear = round(buildYear))
```

## 2.3. Zaawansowana Imputacja (Random Forest)

Do uzupeÅ‚nienia brakÃ³w w kluczowej zmiennej kategorycznej type (rodzaj zabudowy) zastosowano model uczenia maszynowego Random Forest (las losowy). Model zostaÅ‚ wytrenowany na kompletnych obserwacjach (500 drzew decyzyjnych), a nastÄ™pnie wykorzystany do predykcji typu budynku dla brakujÄ…cych rekordÃ³w, co pozwoliÅ‚o na zachowanie struktury danych lepiej niÅ¼ proste uzupeÅ‚nienie dominantÄ….
```{r random_forest, message=FALSE, warning=FALSE,results='hide'}
# -----------------------------------------------------------------------------
# Imputacja Random Forest (Type)
# -----------------------------------------------------------------------------
load("apartments_processed.RData")
is_missing_type <- is.na(apartments_processed$type)

# Trenowanie modelu
train_data <- apartments_processed[!is_missing_type, ]
train_data$type <- droplevels(train_data$type)

model_rf <- randomForest(
  type ~ ., 
  data = train_data, 
  ntree = 500,
  na.action = na.omit 
)

# Predykcja tylko dla brakujÄ…cych
predictions <- predict(model_rf, newdata = apartments_processed[is_missing_type, ])

# Wstawiamy predykcje z powrotem do gÅ‚Ã³wnego zbioru
apartments_processed$type[is_missing_type] <- predictions
```

## 2.4. Wyniki i Weryfikacja KoÅ„cowa

Po zakoÅ„czeniu procesu czyszczenia przeprowadzono:

PonownÄ… walidacjÄ™: Sprawdzono zgodnoÅ›Ä‡ danych z reguÅ‚ami validate.

AnalizÄ™ brakÃ³w (naniar): Potwierdzono wyeliminowanie kluczowych brakÃ³w danych.

Zapis: Przetworzony zbiÃ³r danych zostaÅ‚ zapisany do pliku .RData w celu optymalizacji wydajnoÅ›ci raportu.
